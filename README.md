# spring-spigot

A library that eases the making Spigot plugins.
It enables you to use Spring dependency injection and annotation based autoconfiguration for commonly used Spigot components such as eventlisteners and commands.

## Getting started

### Gradle

```kotlin
annotationProcessor("be.lennertsoffers:spring-spigot:1.0.1")
implementation("be.lennertsoffers:spring-spigot:1.0.1")
```

### Maven

```xml
<dependency>
    <groupId>be.lennertsoffers</groupId>
    <artifactId>spring-spigot</artifactId>
    <version>1.0.1</version>
</dependency>
```

## Usage

### Context

Initialisation should be the first thing your plugin does and cleaning up the latest thing.
That's why I recommend using the `onEnable` and `onDisable` hooks.

Also, you need to add the `@SpigotPlugin` annotation to your plugin main class.

```java
@SpigotPlugin(...)
public final class TestPlugin extends JavaPlugin {
    @Override
    public void onEnable() {
        SpringSpigot.initialize(this);
    }

    @Override
    public void onDisable() {
        SpringSpigot.unload();
    }
}
```

When using this library, Spring dependency injection is the way to go.
Therefore, the library takes care of registering the plugin instance as a bean.
Adding static fields of getters of your plugin type, to your main class will throw an exception because you should always use DI to get the plugin instance.

Note that the main class is also a bean, but constructor injection is not possible (Spigot creates this instance, not Spring).
Use `@Autowired` for field injection instead.

### Generation of plugin.yml

By default, a plugin.yml gets generated by adding the `@SpigotPlugin` annotation to your main class.
If you want to define it yourself, you should set the `generatePluginYml` to false.

The different values of this file are also configurable via the `@SpigotPlugin` annotation.
Commands get automatically added to this file when you choose for autoconfiguration.

### Registering eventlisteners

To register a class as an eventListener, just annotate it with `@EventListener`. This is a meta annotation for `@Component` so let spring handle the creation of instances of your class.

```java
@EventListener
public class TestListener implements Listener {
    @EventHandler
    public void onCommand(Event event) {
        ...
    }
}

```

### Registering commands

Annotate your class with `@PluginCommandExecutor` and fill in at least the name and description.
This is a meta annotation for `@Component` so let spring handle the creation of instances of your class.
If you chose to generate a plugin.yml file, the command gets automatically registered there with the data you provide in the annotation.

```java
@PluginCommandExecutor(
        commandName = "testcommand",
        description = "Test if the command works"
)
public class TestCommand implements CommandExecutor {
    @Override
    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {
        ...
    }
}
```

### Custom enchantments

Custom enchantments can be created by extending the `Enchantment` class of bukkit.
If you want to register this enchantment to the server on startup, use the `@CustomEnchantment` annotation.
It's important to not forget to unload this library `onDisable`, otherwise this will give problems with double registrations of commands.

```java
@CustomEnchantment
public class TestEnchantment extends Enchantment {
    ...
}
```

## License

Distributed under Apache 2.0 License. See [LICENSE.md](./LICENSE.md) for more information. 











